/**
 * @file 枚举
 * 
 * 1. 数字枚举
 * 2. 字符串枚举
 * 3. 异构枚举
 * 4. 计算成员和常量成员
 */

/* 
    使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或
    创建一组有区别的用例。TypeScript支持数字的和基于字符串的枚举。  */

/* ==================== 数字枚举  Numeric enums ===================== */
    enum Direction {
        Up = 1,
        Down,
        Left,
        Right
    }

    /* 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值
    都是不同的。使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型.  */

    enum Response1 {
        No,
        Yes
    }

    function respond(recipient: string, message: Response1): void {
        // ...
        console.log(`${recipient} : ${message}`)
    }

    respond('Kobe', Response1.Yes)
    // respond('Kd',2)     //  第二个参数 只要传入数字就不报错，该枚举属于数字枚举

    /*  不带初始化的枚举，要么放在第一个位置；要么放在使用数字常量或者其他常量初始化的枚举的后面  */
    let getSomeValue: () => number = () => {return 5 };

    enum E {
        A = getSomeValue(),     // 不带初始化
        // B,  // error: 枚举成员必须具有初始化表达式

        B = 1,  // 初始化
        C 
    }

/* ======================= 字符串枚举 String enums =======================

    在一个字符串枚举里，每个成员都必须用字符串字面量或另外一个字符串枚举成员进行初始化。

    由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。字符串枚举允许你提供一个
    运行时有意义的并且可读的值，独立于枚举成员的名字。
*/

/* =================== 异构枚举  Heterogeneous enums =====================
        枚举可以混合字符串和数字，不推荐 */
    enum BooleanInHeter {
        No  = 0,
        Yes = 'YES',
    }

/* ==================== 计算成员和常量成员 =========================== 

    每个枚举成员都带有一个值，它可以是 常量或 计算出来的。 当满足如下条件时，枚举成员被当作是常量：

    1. 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 0: */

        enum E1 { X }

    // 2. 它不带有初始化且它之前的枚举成员是一个 数字常量。

        enum E2 { X, Y, Z}

        enum E3 { X = 1, Y, Z}

    // 3. 枚举成员使用 常量枚举表达式初始化。

        /* 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：

            a. 一个枚举表达式字面量（主要是字符串字面量或数字字面量）
            b. 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）
            c. 带括号的常量枚举表达式
            d. 一元运算符 +, -, ~其中之一应用在了常量枚举表达式
            e. 常量枚举表达式做为二元运算符 +, -, *, /, %, <<, >>, >>>, &, |, ^的操作对象。
                若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。
        */

        enum FileAccess {
            // 常量成员
            None,
            Read   = 1 << 1,
            Write  = 1 << 2,
            ReadWrite  = Read | Write,

            // 计算成员
            G = '123'.length
        }

        /* 注意： 含字符串的枚举中不允许使用计算值 */